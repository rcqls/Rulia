jlvalue <- function(obj, ...) UseMethod("jlvalue", obj)

jlvalue.default <- function(expr, ...) {
  warning(paste0("No jlvalue conversion for ", expr, " !"))
  NULL
}

## Main function to manage returned jlvalue object
# 1) jlexception if thing goes wrong (failure)
# 2) jlfunction if  the returned jlvalue is a Function
# 3) the initial jlvalue if everything is correct
jlvalue_function_with_exception <- function(jlval, code, parent_envir=parent.frame()) {
    if(is.jlexception(jlval)) {
        jlexception(code, jlval)
    } else if (is.jlfunction(jlval)) {
        jlfunction(jlval, parent_envir)
    } else {
        jlval
    }
}

## add code as attribute
jlvalue_with_code <- function(jlval, code) {
    attr(jlval, "code") <- code
    return(jlval)
}

###########################################
## eval functions
## 1) jlvalue mode 
## IMPORTANT: the user knows that the argument is a character and the content is a valid julia code
jlvalue_eval <- function(expr) {
    .jlvalue_eval_with_class(expr)
}

## 2) jleval mode: test on length of obj and jlexception 
jleval <- function(obj, ...) {
    if (length(obj) == 1 && is.character(obj)) {
        jlval <- .jlvalue_eval_with_class(obj)
        jlvalue_function_with_exception(jlval, obj)
    } else {
        warning("Bad input for jlvalue_eval function!")
        NULL
    }
}

## 3) jl mode: see jl() function
################################################

jlvalue_invisible <- function(jlval) {
    if(jlvalue_callR("isnothing", jlval)) {
        invisible(jlval)
    } else {
        jlval
    }
}

jlvalue.jlvalue <- function(jlval, ...) {
    if(.jlvalue_is_null(jlval)) {
        cat("jlvalue is a null external pointer!\n")
    }
    jlval
}

## used to evaluate jl(as.name("<julia expresssion>"))
jlvalue.name <- function(name) jleval(deparse(name))

is.jlvalue <- function(obj) inherits(obj,"jlvalue") && !.jlvalue_is_null(obj)

print.jlvalue <- function(jlval, ...) {
    if(.jlvalue_is_null(jlval)) {
        cat("jlvalue is a null external pointer")
        if(!is.null(attr(jlval, "code"))) {
            cat(" generated by ",attr(jlval, "code"))
        }
        cat("\n")
    } else {
        if (interactive()) {
            invisible(jlvalue_show_display(jlval))
        } else {
            cat(jlvalue_capture_display(jlval))
        }
    }
}

toR.jlvalue <- function(jlval) {
    res <- .jlvalue2R(jlval)
    if (typeof(res) == "externalptr") {
        res
    } else {
        if (is.list(res) && any(sapply(res,is.jlvalue))) {
            sapply(res, toR)
        } else {
            if (is.list(res)) simplify2array(res) else res
        }
    }
}


# apply a method call 
jlvalue_call <- function(meth , ...) {
    args <- list(...)
    if (!is.character(meth)) {
        error("No julia method specified!")
    }
    if (length(args) > 3) {
      .jlvalue_call(meth, ...)
    } else {
      switch(length(args) + 1,
          .jlvalue_call0(meth),
          .jlvalue_call1(meth, ...),
          .jlvalue_call2(meth, ...),
          .jlvalue_call3(meth, ...),
          "Supposed to be done..."
      )
    }
}

jlvalue_callR <- function(meth , ...) toR(jlvalue_call(meth, ...))

jlvalue_func <- function(jlfunc, ...) {
    jlargs <- list(...)
    jlnargs <- length(jlargs)
    .jlvalue_func_call_(jlfunc,jlargs,jlnargs)
}

jlvalue_funcR <- function(jlfunc , ...) toR(jlvalue_func(jlfunc, ...))
