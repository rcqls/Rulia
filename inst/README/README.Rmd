---
title: "Rulia: julia for R"
#author: "RCqls"
output: github_document
---
<!-- Rscript -e "rmarkdown::render('README.Rmd')";rm README.html -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<details>
  <summary><h1>Getting started</h1></summary>

This is an attempt to embed the `julia` language in `R`.

Let us notice that there already exist alternatives `R` packages (see [`JuliaCall`](https://github.com/Non-Contradiction/JuliaCall) README page for a complete list).
[`JuliaCall`](https://github.com/Non-Contradiction/JuliaCall) is the main one. However, the big difference between `Rulia` and `JuliaCall` is that `JuliaCall` depends on the `R` package `Rcpp` and the `julia` package `RCall.jl`.
In other words, `Rulia` only depends on the C APIs of `R` and `julia`. There is then **no dependencies**. 

Also `Rulia` is the next step of the preliminary project called [`jl4R`](https://github.com/rcqls/jl4R) started more than 10 years ago. The author thinks that `Rulia` is a more funny name than `jl4R`. 

## Install

1.  Install Julia (all Operating System)

Install [Julia](https://julialang.org/downloads/). For Windows users
donâ€™t forget to select `PATH` in the installer. As mentionned in this page, prefer the `juliaup` installation one.

2.  Windows user setup

- Install [RTools](https://cran.r-project.org/bin/windows/Rtools/) and a
  terminal with bash (for instance, [Git
  Bash](https://gitforwindows.org/))
- Add Rscript in the `PATH` environment variable (see for example [this
  page](https://www.hanss.info/sebastian/post/rtools-path/))

3.  Bash installation (all Operating Systems)

``` bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/rcqls/Rulia/HEAD/inst/install.sh)"
```

## Quick live session

```{r}
require(Rulia)
jl(`1`)
jl(1)
v_jl <- jl(c(1,3,2))
v_jl        # notice the julia output format 
class(v_jl)
typeof(v_jl)
jltypeof(v_jl)
R(v_jl)     # here the R output format 
## a potentially useful task is to call a julia fonction applied on an R ao object
jl(sum)(c(1,3,2))           # the result is a julia object (here a jlvalue R object)
# and then get the result as an R object
jl(sum)(c(1,3,2)) |> R()    # corresponding in the julia side to `sum([1.0, 3.0, 2.0])`
```

The only thing to do in order to initialize `julia` is to load the library `Rulia`.

Then, it is pretty direct to:

1. convert an `R` object to `julia` object (in fact, a `jlvalue` external pointer in the `R` side)
1. apply a `julia` function to the `R` object
1. and finally convert the `julia` result to an `R` object
</details>

<details>
<summary><h1><code>Rulia</code> in user-friendly mode</h1></summary>

1. `Rulia` package when loaded, initializes a `julia` session useable inside the current `R` session.
1. `jl()` is the **only user friendly function** to use in order to:

* execute regular  `julia` code inside `R`
* convert `R` object in `julia` object
* call `julia` function returned by `jl()` function itself
* define `julia` variable(s) directly inside the `julia` session

<details><summary><h2><code>jl()</code> as evaluation of <code>julia</code> expressions</h2></summary>

Thanks to the `jl()` function, `Rulia` allows us to call `julia` (possibly multilines) expression given with expression between backticks "\`" (i.e. of class `name` or type `symbol`).

```{r}
jl(`[1,3,2]`)
jl(`[1.0,3.0,2.0]`)
jl(`(a=1,b=[1,3])`)
jl(`[
    1.0,
    3.0,
    2.0
    ]`)
```

All these commands return `jlvalue` objects which are `R` external pointers
wrapping `jl_value_t*` values.
</details>
<details><summary><h2><code>jl()</code> as <code>julia</code> converter of <code>R</code> objects</h2></summary>

A lot of `R` objects can be converted in `julia` objects by simply put them as argument of the `jl()` function.

```{r}
jl(c("one","three","two"))
jl(c(TRUE,FALSE,TRUE))
jl(c(1L,3L,2L))
jl(TRUE)
jl(1L)
jl(1)
jl("1")
jl(matrix("one"))
jl(list(a=c(TRUE,FALSE,TRUE), b=1L))
```
</details>
<details><summary><h2><code>jl()</code> function to call <code>julia</code> function inside <code>R</code> system</h2></summary>

The main use of the `Rulia` package is to call `julia` function (in fact, `julia` method because of the implicit **multiple dispatching** provided by `julia`) inside the `R` system. The more challenging goal of `Rulia` is to try to provide a `R` syntax to call `julia` function which as most as possible close to the original `julia` syntax.

Lets start with a simple example:

```{r}
jl(rand)(`2`)   # julia integer
jl(rand)(2L)    # implicitly converted R integer
```

In fact both these lines are user-friendy simplified versions of what would be necessary to call:

```{r}
jl(rand)(jl(`2`))   # julia integer
jl(rand)(jl(2L))    # implicitly converted R integer
```

The challenging primary goal in `Rulia` is:

    An expression in `Rulia` only need a unique call of the `jl()` function (whenever many `jl()` calls would be normally necessary).

How is a such trick possible?

Let us first observe the result returned  when the argument of `jl()` is an expression of a `julia function`.

```{r}
jl(`sum`)       # the usual way
jl(sum)         # which is equivalent to the simplified way thanks to R
class(jl(sum))  # this is not directly a jlvalue R object
```

Let us comment what is special here. `jl(sum)` should normally returns an `R` object of class `jlvalue`.
But since our goal is to apply the function, `jl(sum)` is tranformed in a `jlfunction` that can be called with arguments that need to be `R` objects of class `jlvalue`.
Thanks to the metaprogramming provided by `R`, one only needs to provide the arguments of the `jlfunction` with:

* `R` objects implicitly converted to `jlvalue` objects  
* `julia` expressions given between backticks also implicitly executed (for you) in the `julia` side to finally provide `jlvalue` results  

The main point is that no need of `jl()` is required whe specifying arguments of the `jlfunction`.
</details>
<details><summary><h2>Conversion <code>julia</code> to <code>R</code></h2></summary>

 </details>

<details><summary><h2><code>Rulia</code> in the statistic context</h2></summary>

* `DataFrame` (`julia` side) and `data.frame` (`R` side)

```{r}
require(Rulia)
jlusing(DataFrames)
jl(`(a=1,b=DataFrame(a=1:3,b=2:4))`) -> nt_jl
nt_jl
list(jltypeof(nt_jl), typeof(nt_jl), class(nt_jl))
```

To compute `julia` code needs to be put between two backticks and not between quote or double quote (which is a regular `R` character object to be converted in `julia`). It is better to insist, don't confuse the third line before and the first following one (which returns a simple `julia` object of type `String`):

```{r}
jl("(a=1,b=DataFrame(a=1:3,b=2:4))") -> str_jl
str_jl
list(jltypeof(str_jl), typeof(str_jl), class(str_jl))
```

As expected, `Rulia` offers conversion in both directions, `julia` to `R` and conversely `R` to `julia`

```{r}
nt_R <- R(nt_jl)
nt_R
```

and conversely `R` to `julia`

```{r}
jl(nt_R)
```

* `CategoricalArray` (`julia` side) and `factor` (`R` side)

```{r}
require(Rulia)
jlusing(CategoricalArrays)
ca_jl <- jl(`categorical(["titi","toto","titi"])`)
ca_jl
list(jltypeof(ca_jl), typeof(ca_jl), class(ca_jl))
```

Below, the conversion `julia` to `R`

```{r}
ca_R <- R(ca_jl)
ca_R
```

and conversely, the conversion `R` to `julia`

```{r}
jl(ca_R)
```
</details>
</details>


<details>
<summary><h1><code>Rulia</code> in low level mode</h1></summary>
TODO
</details>

<details>
<summary><h1>R Finalizers</h1>

Following the documentation on embedding `julia`, a system of preserved
references to `julia` values has been created. An `R` finalizer is
assiocated to each `jlvalue` object (in fact, an `R` external pointer
wrapping some `jl_value_t*` value). Whenever the `jlvalue` is gabarged
collected, the reference on the associated `julia` value is also
dereferenced which is then cleaned up by the `julia` garbage collector.

</details>